;Description
;#8
;Разделить исходный список из целых чисел на два списка:
;список положительных чисел и список отрицательных чисел.

;Code
(defun split (lst)
    (cond                   
        ((null lst)        
            '(nil nil)     
        )
        (t                  
            ((lambda (l n)                            
                    (cond 
                        ((>= n 0)
                            (cons (cons n (car l)) (cdr l))
                        )
                        (t
                            (cons (car l) (cons (cons n (cadr l)) nil ))
                        )
                    )
            ) (split (cdr lst)) (car lst))
        )
    )
)

;Test cases
;1) (-1 2 -3 4) -> ((2 4) (-1 -3))
(print (split '(-1 2 -3 4)))

;2) (-1 2 -3 4) -> ((0 0 5) (-1)) 
(print (split '(0 0 -1 5)))

;3) () -> (NIL NIL)
(print (split '()))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#13
;Удалить из исходного списка все повторные вхождения элементов

;Code


;Test cases

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#15
;Вычислить скалярное произведение векторов, заданных списками целых чисел

;Code
(defun scalar (lst1 lst2)
    (cond
		((null lst1)
			0
		)
		(t
			(+ (* (car lst1) (car lst2)) (scalar (cdr lst1) (cdr lst2)))
		)
	)
)

;Test cases;
;1) (1 3) (2 2) -> 8
(print (scalar '(1 3) '(2 2)))

;2) (-1 -3) (0 2) -> -6
(print (scalar '(-1 -3) '(0 2)))

;3) () () -> 0
(print (scalar NIL NIL))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#21
;Удалить из списка первое вхождение данного элемента на верхнем уровне.


;Code
(defun delete-element (lst element)
	(cond
		((null lst)
			nil
		)
		((= (car lst) element)
			(cdr lst)
		)
		(t
			(cons car(lst) (delete-element (cdr lst) element))
		)
	)
)

;Test cases
;1) ((1 2 3) 3) ->  (1 2)
(print (delete-element (1 2 3) 3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#25
;Удалить из списка каждый четный элемент

;Code
(defun delete-even (lst)
    (cond                   
        ((null lst)        
            nil   
        )
        (t
			(cons (car lst) (delete-even (cddr lst)))            
        )
    )
)

;Test cases
;1) (1 2 3 4 5) -> (1 3 5)
(print (delete-even '(1 2 3 4 5)))

;2) (-1 0 -2 5 7 9 11 0 -3 3454 -4646) -> (-1 -2 7 11 -3 -4646) 
(print (delete-even '(-1 0 -2 5 7 9 11 0 -3 3454 -4646)))

;3) nil -> nil
(print (delete-even NIL))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#28
;Вычислить, сколько всего атомов в списке (списочной структуре)

;Code


;Test cases

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#32
;Определить предикат МНОЖЕСТВО-Р, который проверяет, является ли список
;множеством, т.е. входит ли каждый элемент в список лишь один раз.

;Code

;Test cases

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#42
;Найти максимальное из значений, находящихся в вершинах дерева.

;Code

;Test cases

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#45
;Предположим, что у имени города есть свойства х и у, которые содержат координаты места нахождения города
;относительно некоторого начала координат.
;Напишите функцию (РАССТОЯНИЕ a b), вычисляющую расстояние между городами а и b.

;Code

;Test cases

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Description
;#46
;Предположим, что отец и мать некоторого лица, хранятся как значения соответствующих свойств у символа, обозначающего это лицо.
;Напишите функцию (РОДИТЕЛИ x), которая возвращает в качестве значения родителей,
;и предикат (СЕСТРЫ-БРАТЬЯ x1 x2), который истинен в случае,
;если x1 и x2 — сестры или братья, родные или с одним общим родителем.


;Code

;Test cases